"use strict";(self.webpackChunkbenchmarking=self.webpackChunkbenchmarking||[]).push([[436],{436:(_,m,t)=>{t.r(m),t.d(m,{MergeTestComponent:()=>c});var l=t(6895),i=t(7579),p=t(6451),u=t(4654),s=t(4870),e=t(4650);let c=(()=>{class a{constructor(){this.codeSnippet="\n// making an array here because merge needs to be spread\n  private streams = [makeStream(1, this.runStream$),\n    makeStream(2, this.runStream$),\n    makeStream(3, this.runStream$)];\n  testStream$ = merge(...this.streams)\n  ",this.runStream$=new i.x,this.streams=[(0,s.lV)(1,this.runStream$),(0,s.lV)(2,this.runStream$),(0,s.lV)(3,this.runStream$)],this.testStream$=(0,p.T)(...this.streams)}}return a.\u0275fac=function(r){return new(r||a)},a.\u0275cmp=e.Xpm({type:a,selectors:[["app-concat-test"]],standalone:!0,features:[e.jDz],decls:7,vars:3,consts:[[3,"codeSnippet","runStream$","testStream$"]],template:function(r,n){1&r&&(e.TgZ(0,"app-observable-area",0)(1,"p"),e._uU(2,"merge will run all streams in parallel, and emit each one as it completes"),e.qZA(),e.TgZ(3,"p"),e._uU(4,"it's syntax is also a bit weird; it takes a list of arguments, not an array, ergo ...[] it"),e.qZA(),e.TgZ(5,"p"),e._uU(6,"Good to quickly complete all streams in parallel and emit each time (procedural loading)"),e.qZA()()),2&r&&e.Q6J("codeSnippet",n.codeSnippet)("runStream$",n.runStream$)("testStream$",n.testStream$)},dependencies:[l.ez,u.U],styles:[".observable_area[_ngcontent-%COMP%]{max-width:400px}"]}),a})()}}]);