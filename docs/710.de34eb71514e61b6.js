"use strict";(self.webpackChunkbenchmarking=self.webpackChunkbenchmarking||[]).push([[710],{7710:(S,l,a)=>{a.r(l),a.d(l,{ShareColdTestComponent:()=>b});var o=a(6895),i=a(7579),p=a(7445),c=a(8505),u=a(3099),m=a(4654),e=a(4650);let d=(()=>{class t{constructor(){this.codeSnippet="\ntestStream$ = interval(1000).pipe(\n    tap((i) => this.runStream$.next({\n      label: `${ i }`,\n      time: Date.now()\n    })),\n    share()\n  );\n  ",this.runStream$=new i.x,this.testStream$=(0,p.F)(1e3).pipe((0,c.b)(s=>this.runStream$.next({label:`${s}`,time:Date.now()})),(0,u.B)())}}return t.\u0275fac=function(s){return new(s||t)},t.\u0275cmp=e.Xpm({type:t,selectors:[["app-share-test"]],standalone:!0,features:[e.jDz],decls:5,vars:4,consts:[[3,"codeSnippet","runStream$","showSubscriberLabels","testStream$"]],template:function(s,n){1&s&&(e.TgZ(0,"app-observable-area",0)(1,"h1"),e._uU(2,"Share Test"),e.qZA(),e.TgZ(3,"p"),e._uU(4,"In a shared setup, each subscriber is added after the streams logic, This means emits are synchronised for our example."),e.qZA()()),2&s&&e.Q6J("codeSnippet",n.codeSnippet)("runStream$",n.runStream$)("showSubscriberLabels",!0)("testStream$",n.testStream$)},dependencies:[o.ez,m.U],styles:[".observable_area[_ngcontent-%COMP%]{max-width:400px}"]}),t})(),h=(()=>{class t{constructor(){this.codeSnippet="\n  testStream$ = interval(1000).pipe(\n    tap((i) => this.runStream$.next({\n      label: i,\n      time: Date.now()\n    }))\n  );\n  ",this.runStream$=new i.x,this.testStream$=(0,p.F)(1e3).pipe((0,c.b)(s=>this.runStream$.next({label:`${s}`,time:Date.now()})))}}return t.\u0275fac=function(s){return new(s||t)},t.\u0275cmp=e.Xpm({type:t,selectors:[["app-cold-test"]],standalone:!0,features:[e.jDz],decls:5,vars:4,consts:[[3,"codeSnippet","runStream$","showSubscriberLabels","testStream$"]],template:function(s,n){1&s&&(e.TgZ(0,"app-observable-area",0)(1,"h1"),e._uU(2,"Cold Test"),e.qZA(),e.TgZ(3,"p"),e._uU(4,"In a cold setup, each added subscriber will run it's own logic, This means emits are not synchronised for our example."),e.qZA()()),2&s&&e.Q6J("codeSnippet",n.codeSnippet)("runStream$",n.runStream$)("showSubscriberLabels",!0)("testStream$",n.testStream$)},dependencies:[o.ez,m.U],styles:[".observable_area[_ngcontent-%COMP%]{max-width:400px}"]}),t})();console.log("loaded FromPromiseTestComponent");let b=(()=>{class t{}return t.\u0275fac=function(s){return new(s||t)},t.\u0275cmp=e.Xpm({type:t,selectors:[["app-from-promise-test"]],standalone:!0,features:[e.jDz],decls:14,vars:0,consts:[[2,"display","grid","grid-template-columns","1fr 1fr"]],template:function(s,n){1&s&&(e.TgZ(0,"div")(1,"p"),e._uU(2,"There's two types of observables - Hot and Cold"),e.qZA(),e.TgZ(3,"p"),e._uU(4,"Cold observables aren't ready for subscribers - all logic created per subscriber"),e.qZA(),e.TgZ(5,"p"),e._uU(6,"While Hot observables are ready for new subscribers - all logic is ran once then given to all subscribers"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"This can cause extremely negative performance outcomes, but also lead to hugely confusing logical outcomes if forgotten"),e.qZA(),e.TgZ(9,"p"),e._uU(10," In either case, if there's no subscribers the logic doesn't run in the background "),e.qZA(),e.TgZ(11,"div",0),e._UZ(12,"app-share-test")(13,"app-cold-test"),e.qZA()())},dependencies:[o.ez,d,h],styles:[".observable_area[_ngcontent-%COMP%]{max-width:400px}"]}),t})()}}]);